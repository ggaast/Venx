use core::ops::{Index, IndexMut};

use spirv_std::glam::UVec3;

use super::layer::layer::Layer;

#[derive(Clone)]
pub struct RawPlat {
    pub position: (i32, i32, i32),
    pub rotation: (i32, i32, i32),
    // pub bcs: Vec<()>,
    // pub texs: Vec<()>,
    // pub sbc: SmallBlockCollection,
    /// Maximal depth of plat, can be extended and/or shrinked
    /// 2^depth represents maximum world size
    pub depth: u8,

    /// Each layer is laying on top of layers behind
    /// To provide cross-game exprience, layers specified
    /// Quick tour of layers and its responsobilities:
    /// 0 - Base layer: Used for simple terrain generation
    /// 1 - Tmp layer: Quick layer for temprorary voxel generated by FWGen
    /// 2 - Schematic: Used to place autopasted schematics, also used for AI buildings provided by FWGen
    /// 3 - Canvas: Each voxel you want to place as a player will go there
    //pub layers: Vec<Layer>,
    pub base: Layer,
    pub tmp: Layer,
    pub schem: Layer,
    pub canvas: Layer,
}

impl RawPlat {
    pub fn new(depth: u8, chunk_level: u8, segment_level: u8) -> Self {
        RawPlat {
            //controller: Controller::new(depth, chunk_level, segment_level),
            position: (0, 0, 0),
            rotation: (0, 0, 0),
            depth,
            base: Layer::new::<1_280>(depth),
            tmp: Layer::new::<128>(depth),
            schem: Layer::new::<128>(depth),
            canvas: Layer::new::<128>(depth),
        }
    }
    pub fn depth(&self) -> u8 {
        self.depth as u8
    }

    pub fn size(&self) -> u32 {
        1 << (self.depth())
    }
}

impl Index<usize> for RawPlat {
    type Output = Layer;

    fn index(&self, index: usize) -> &Self::Output {
        match index {
            0 => &self.base,
            1 => &self.tmp,
            2 => &self.schem,
            3 => &self.canvas,
            _ => panic!("There is no layer on {} index", index),
        }
    }
}

impl IndexMut<usize> for RawPlat {
    fn index_mut(&mut self, index_mut: usize) -> &mut Self::Output {
        match index_mut {
            0 => &mut self.base,
            1 => &mut self.tmp,
            2 => &mut self.schem,
            3 => &mut self.canvas,
            _ => panic!("There is no layer on {} index", index_mut),
        }
    }
}

use super::{layer::layer::Layer, node::Node, node_l2::NodeL2};
use core::ops::{Index, IndexMut};

// TODO: rename to RawPlatMut and create LayerMut
#[derive(PartialEq, Debug)]
pub struct RawPlat<'a> {
    pub position: (i32, i32, i32),
    pub rotation: (i32, i32, i32),
    // pub bcs: Vec<()>,
    // pub texs: Vec<()>,
    // pub sbc: SmallBlockCollection,
    /// Maximal depth of plat, can be extended and/or shrinked
    /// 2^depth represents maximum world size
    pub depth: usize,

    /// Each layer is laying on top of layers behind
    /// To provide cross-game exprience, layers specified
    /// Quick tour of layers and its responsobilities:
    /// 0 - Base layer: Used for simple terrain generation
    /// 1 - Tmp layer: Quick layer for temprorary voxel generated by FWGen
    /// 2 - Schematic: Used to place autopasted schematics, also used for AI buildings provided by FWGen
    /// 3 - Canvas: Each voxel you want to place as a player will go there
    // pub base: Layer<'a>,
    // pub tmp: Layer<'a>,
    // pub schem: Layer<'a>,
    // pub canvas: Layer<'a>,
    pub layers: [Layer<'a>; 4],
}

impl<'a> RawPlat<'a> {
    pub fn new(
        depth: usize,
        _chunk_level: usize,
        _segment_level: usize,
        base: (&'a mut [Node], &'a mut [NodeL2]),
        tmp: (&'a mut [Node], &'a mut [NodeL2]),
        schem: (&'a mut [Node], &'a mut [NodeL2]),
        canvas: (&'a mut [Node], &'a mut [NodeL2]),
    ) -> Self {
        assert!(depth > 4);
        RawPlat {
            position: (0, 0, 0),
            rotation: (0, 0, 0),
            depth,
            layers: [
                Layer::new(depth, base.0, base.1),
                Layer::new(depth, tmp.0, tmp.1),
                Layer::new(depth, schem.0, schem.1),
                Layer::new(depth, canvas.0, canvas.1),
            ],
        }
    }
    /// Return named layers. Might be useful if you want to get all names in single array
    /// TODO: Actually it needs to be moved in layer itself
    pub fn layers(&'a self) -> [(&'a str, &'a Layer<'a>); 4] {
        [
            ("base", &self.layers[0]),
            ("tmp", &self.layers[1]),
            ("schem", &self.layers[2]),
            ("canvas", &self.layers[3]),
        ]
    }

    pub fn depth(&self) -> usize {
        self.depth as usize
    }

    pub fn size(&self) -> u32 {
        1 << (self.depth())
    }
}
impl<'a> Index<usize> for RawPlat<'a> {
    type Output = Layer<'a>;

    fn index(&self, index: usize) -> &Self::Output {
        &self.layers[index]
    }
}

impl<'a> IndexMut<usize> for RawPlat<'a> {
    fn index_mut(&mut self, index_mut: usize) -> &mut Self::Output {
        &mut self.layers[index_mut]
    }
}
// #[deprecated = "No easy way to import in scope with shortcuts. Use [Layer] associated constants instead: [Lr::BASE]"]
#[repr(usize)]
pub enum LayerIndex {
    Base = 0,
    Tmp = 1,
    Schem = 2,
    Canvas = 3,
}

impl<'a> Index<LayerIndex> for RawPlat<'a> {
    type Output = Layer<'a>;

    fn index(&self, index: LayerIndex) -> &Self::Output {
        &self.layers[index as usize]
    }
}

impl<'a> IndexMut<LayerIndex> for RawPlat<'a> {
    fn index_mut(&mut self, index_mut: LayerIndex) -> &mut Self::Output {
        &mut self.layers[index_mut as usize]
    }
}
/// Quickly create raw plat for testing
///
/// `!(plat_name, depth ?usize = 8, len ?usize = 128, len2 ?usize = len, lenrest ?usize = 128)`
///
/// Where `?` means optional and `=` default values
#[macro_export]
macro_rules! quick_raw_plat {
    ($plat:ident, depth $depth:tt, len $layer_len:tt, len2 $layer_len_l2:tt, lenrest $lenrest:tt) => {
        extern crate alloc;
        extern crate std;
        let mut base = (alloc::vec![Node::default(); $layer_len], alloc::vec![crate::plat::node_l2::NodeL2::default(); $layer_len_l2]);
        let mut tmp = (alloc::vec![Node::default(); $lenrest],  alloc::vec![crate::plat::node_l2::NodeL2::default(); $lenrest]);
        let (mut schem, mut canvas) = (tmp.clone(), tmp.clone());
        let mut $plat = std::boxed::Box::new(RawPlat::new(
            $depth,
            5,
            5,
            (&mut base.0, &mut base.1),
            (&mut tmp.0, &mut tmp.1),
            (&mut schem.0, &mut schem.1),
            (&mut canvas.0, &mut canvas.1),
        ));
    };
    ($plat:ident, depth $depth:tt, len $layer_len:tt, lenrest $lenrest:tt) => {
        extern crate alloc;
        extern crate std;
        let mut base = (alloc::vec![Node::default(); $layer_len], alloc::vec![crate::plat::node_l2::NodeL2::default(); $layer_len]);
        let mut tmp = (alloc::vec![Node::default(); $lenrest],  alloc::vec![crate::plat::node_l2::NodeL2::default(); $lenrest]);
        let (mut schem, mut canvas) = (tmp.clone(), tmp.clone());
        let mut $plat = std::boxed::Box::new(RawPlat::new(
            $depth,
            5,
            5,
            (&mut base.0, &mut base.1),
            (&mut tmp.0, &mut tmp.1),
            (&mut schem.0, &mut schem.1),
            (&mut canvas.0, &mut canvas.1),
        ));
    };
    ($plat:ident, depth $depth:tt, len $layer_len:tt) => {
        extern crate alloc;
        extern crate std;
        let mut base = (alloc::vec![crate::plat::node::Node::default(); $layer_len], alloc::vec![crate::plat::node_l2::NodeL2::default(); $layer_len]);
        let mut tmp = (alloc::vec![crate::plat::node::Node::default(); 128],  alloc::vec![crate::plat::node_l2::NodeL2::default(); 128]);
        let (mut schem, mut canvas) = (tmp.clone(), tmp.clone());
        let mut $plat = std::boxed::Box::new(crate::plat::raw_plat::RawPlat::new(
            $depth,
            5,
            5,
            (&mut base.0, &mut base.1),
            (&mut tmp.0, &mut tmp.1),
            (&mut schem.0, &mut schem.1),
            (&mut canvas.0, &mut canvas.1),
        ));
    };

    ($plat:ident, depth $depth:tt) => {
        extern crate alloc;
        extern crate std;
        let mut base = (alloc::vec![Node::default(); 128], alloc::vec![crate::plat::node_l2::NodeL2::default(); 128]);
        let mut tmp = (alloc::vec![Node::default(); 128],  alloc::vec![crate::plat::node_l2::NodeL2::default(); 128]);
        let (mut schem, mut canvas) = (tmp.clone(), tmp.clone());
        let mut $plat = RawPlat::new(
            $depth,
            5,
            5,
            (&mut *base.0, &mut base.1),
            (&mut *tmp.0, &mut tmp.1),
            (&mut *schem.0, &mut schem.1),
            (&mut *canvas.0, &mut canvas.1),
        );
    };
    ($plat:ident) => {
        extern crate alloc;
        extern crate std;
        let mut base = (alloc::vec![Node::default(); 128], alloc::vec![crate::plat::node_l2::NodeL2::default(); 128]);
        let mut tmp = (alloc::vec![Node::default(); 128],  alloc::vec![crate::plat::node_l2::NodeL2::default(); 128]);
        let (mut schem, mut canvas) = (tmp.clone(), tmp.clone());
        let mut $plat = RawPlat::new(
            8,
            5,
            5,
            (&mut *base.0, &mut base.1),
            (&mut *tmp.0, &mut tmp.1),
            (&mut *schem.0, &mut schem.1),
            (&mut *canvas.0, &mut canvas.1),
        );
    };
}
